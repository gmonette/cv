#'
#' NEW (up to 2024-12-28):
#'
#' - rewrote diffts and diffinvts to work without the constraint
#'   that the number of leadup cases and the number of cases to predict
#'   are multiple of seasonal periods
#' - used a kludge to fix a problem with arima not converging
#'   when using update.Arima to get a model matrix for new data
#' - See examples at end of file using
#' - Changed default when applying model to predict from
#'   ARMA residuals to demean = FALSE, resulting in a reduction
#'   in approximation error to arima's predictions of future data
#'   by a factor of ~10.
#' -
#'
#' TODO:
#'
#' - See Bergmeyer et al. Note of validity of cross-validation
#'   that advocates random folds to see whether and how they
#'   handle differencing and leadup data
#'
#' Differencing and Antidifferencing time series: vectors and matrices
#'
#' - diffts now works on vectors, ts objects, matrices
#' - the usual properties of 'ts' objects don't work
#'   because these objects can have multiple seasonal
#'   differencing components
#' - Issues: differencing factors
#'

library(magrittr)
library(cv)
library(latticeExtra)

Diff <- function(x, ...) {

  # Note: so far there's only a default method that works
  # with vectors and matrices
  # It's tempting to write a method for data frames
  # but, if a regression includes factors, or other
  # predictors that generate column(s) of the model matrix
  # that are more complex than that generated by a simple
  # numerical predictor, differencing the contents of the
  # data frame will not produce the correct
  # 'base' ARMA model when there is differencing in
  # an ARIMA model. The differencing needs to be applied
  # to the model matrix.
  #

  UseMethod('Diff')
}

Diff.default <- function(
    x,               # a vector or matrix
    order = 1 * (seasonal == 0),
    seasonal = 1 * (period != 1),
    period = 1) {
  if(seasonal > 0) {                 # seasonal order first
    for(i in 1:seasonal){
      x <- diffts(x, order = 1, period = period)
    }
  }
  if(order > 0) {
    for(i in 1:order){
      x <- diffts(x, order = 1, period = 1)
    }
  }
  x
}


diffts <- function(x, order, period) {
  #
  # works on matrices and vectors
  #
  # - returns a result that is 'order * period' shorter
  #   than input.
  #

  if(order > 1) return(diffts(diffts(x, order = order - 1, period = period), order = 1, period = period))
  if(order == 0) return(x)

  atts <- list(
    x = x,
    period = period,
    periods = c(attr(x,'periods'), period),
    offset = if(is.null(attr(x,'offset'))){
      period
    } else {
      period + attr(x,'offset')
    })

  r <- diff(x, lag = period)
  for(i in seq_along(atts)) attr(r, names(atts[i])) <- atts[[i]]
  r
}


rediffts <- function(x, like) {
  #
  # apply differencing to x like differencing performed in 'like'
  #
  periods <- attr(like, 'periods')

  ret <- x

  for(p in periods){
    ret <- diffts(ret, order = 1, period = p)
  }
  ret
}

if(FALSE){   # tests

  #
  # if x is a matrix:
  #
  x <- cbind((1:36)^3, 1)
  colnames(x) <- c('one','two')
  rownames(x) <- 1:36
  Diff(x, period = 12)
  Diff(x, period = 12) %>% class
  #
  # if x is a vector
  #
  x <- (1:36)^3
  names(x) <- paste0('x',1:36)
  Diff(x, period = 12)
  Diff(x, period = 12) %>% Diff(period = 3) %>% Diff()
  #
  #
  xx <- Diff(x, order = 2, seasonal = 2, period = 12)
  str(xx)
  Diff(x, seasonal = 3, period = 12) %>% attributes
  # Diff(x, seasonal = 4, period = 12)

  x <- (1:24)^3
  Diff(x) %>% attributes
  diffts(x, order = 1, period = 1) %>% attributes


  Diff(Diff(x))
  Diff(Diff(Diff(x)))
  xx <- Diff(Diff(Diff(x)))


  xx2 <- Diff(x, order = 3)

  all.equal(xx, xx2)

  # Seasonal

  Diff(x, period = 3)

  x1 <- Diff(x, seasonal = 2, period = 3)
  x2 <- Diff(Diff(x, period = 3), period = 3)

  all.equal(x1, x2)

  #
  # Does 'rediffts' do the right thing?
  #
  xm <- cbind(cube =(1:36)^3, square = (1:36)^2)

  xmres <- Diff(xm, order = 2, seasonal = 1, period = 12)

  xmres2 <- rediffts(xm, like = xmres)
  all.equal(xmres, xmres2)


  #
  # Periods must divide into previous periods
  #

  Diff(x, period = 12)
  Diff(x, period = 12) %>% Diff(period = 3) # monthly and quarterly

}
#
# but
#

# Diff(x, period = 12) %>% Diff(period = 5) # doesn't work

# Diff(x, period = 12) %>% Diff(order = 3) # always works if there's anything left

#
# Antiderivative
#

Diffinv <- function(x, ...) {
  UseMethod('Diffinv')
}
Diffinv.default <- function(x, all = TRUE, at = NA, val = NA, ...){
  # idea:
  # Take a differenced object and
  #
  # - just antidifference 'into' the original object by using
  #   the corresponding values derived from the original object
  #   when antidifferencing.  This has the result of returning
  #   the original object.
  #
  # - antidifference into a different object as one would
  #   when using a model to predict with a different
  #   trigger series
  #
  #
  if(is.na(at)) {
    if(!all) {
      diffinvts(x)  # antidifference one step
    } else {
      depth <- length(attr(x, 'periods'))
      ret <- x
      for(i in 1:depth) {
        ret <- diffinvts(ret)
      }
    }
  }
  ret
}


diffinvts <- function(x, at = 1, value = NA, period = attr(x, 'period')) {
  #
  # period:  only used if antidifferencing a raw vector
  #          i.e. a vector not created by Diff
  #          For vectors created by Diff, the period attribute of x is used

  if(is.null(period)) period <- 1

  ismat <- is.matrix(x)
  xx <- as.matrix(x)

  if(is.null(xp <- attr(x,'x'))) {
    xp <- matrix(0,ncol = ncol(xx), nrow = 0)
  } else {
    xp <- as.matrix(xp)
  }

  if(nrow(xp) < period){
      r <- rbind(
        matrix(0, ncol = ncol(xx), nrow = period - nrow(xp)),
        xp,
        xx)
    } else {
      r <- rbind(xp[seq_len(period),,drop = FALSE], xx)
    }

  r <- diffinv(r, lag = period)
  r <- r[-seq_len(period),,drop = FALSE]

  if(!ismat) r <- drop(r)

  attr(r,'x') <- attr(attr(x, 'x'), 'x')
  attr(r,'period') <- attr(attr(x, 'x'), 'period')
  if(is.null(attr(r, 'period'))) attr(r, 'period') <- period
  attr(r,'periods') <- attr(attr(x,'x'), 'periods')

  r
}

if(FALSE){


  x <- (1:12)^3
  xx <- Diff(x, period = 3)
  xxx <- Diff(xx, period = 2)

  length(xxx)
  xxxi <- diffinvts(xxx)


  xxxi == xx

  all.equal(xxxi, xx)

  xx2 <- Diff((1:12)^3, order = 2, period = 3)

  xx2 %>% Diffinv
  xxq <- xx2 %>% diffinvts %>% diffinvts
  all.equal(xxq, xx)
  xxq == xx

  xx2 %>% diffinvts %>% diffinvts %>% diffinvts # FIX has period but no periods attr
  #
}
#

#
# Modelling and predicting
#
# The goal is to be able to apply an arima model
# to predict with new data
#
# To do this we need to:
#
# - difference new Y and new xreg
# - difference leadup Y and leadup xreg to get ARMA residuals
# - Use model on ARMA residuals to get ARMA predicted residuals
# - Since the residuals are ARMA (in contrast with whitened residuals)
#   we need to apply 'pi' weights for prediction.
# - Add predicted value from the regression model
# - Antidifference to get predicted value
#

arma2psi <- function(ar=0, ma=0, ar.seasonal=0, ma.seasonal=0,
                     period, lag.max=100, trunc.psi=TRUE,
                     trunc.at=0.001, ...){
  #
  # Copied from scratch/notes_john/arma2psi.R
  #
  lag.max.tot <- if (!(missing(period) || is.na(period))) lag.max*period else lag.max
  psi <- ARMAtoMA(ar = ar, ma = ma, lag.max=lag.max.tot)
  if (!(missing(period) || is.na(period))) {
    psi.seasonal <- ARMAtoMA(ar = ar.seasonal, ma = ma.seasonal, lag.max=lag.max)
    psi <- psi + as.vector(rbind(matrix(0, period - 1, lag.max),
                                 psi.seasonal))
  }
  if (trunc.psi){
    which.psi <- which(abs(psi) >= trunc.at)
    if (length(which.psi) == 0) {
      return(numeric(0))
    }
    if (max(which.psi) == lag.max.tot) {
      warning("all ", lag.max.tot, " psi weights retained")
    } else {
      psi <- psi[1:max(which.psi)]
    }
  }
  psi
}

arma2pi <- function(ar=0, ma=0, ar.seasonal=0, ma.seasonal=0,
                    period, lag.max=100, trunc.pi=TRUE,
                    trunc.at=0.001, ...){
  #
  # Returns 'pi' weights to predict Y(t+h) recursively from Y(t-k),...,Y(t)
  # where Ys are ARMA(ar,ma)
  #
  # Dual to psi:
  #
  # use -ARMAtoMA(ar = -ma, ma = -ar)  with B&D signs for ma parameters
  #
  #

  lag.max.tot <- if (!(missing(period) || is.na(period))) lag.max*period else lag.max
  Pi <- - ARMAtoMA(ar = -ma, ma = -ar, lag.max=lag.max.tot)
  if (!(missing(period) || is.na(period))) {
    Pi.seasonal <- - ARMAtoMA(ar = - ma.seasonal, ar = - ma.seasonal, lag.max=lag.max)
    Pi <- Pi + as.vector(rbind(matrix(0, period - 1, lag.max),
                               Pi.seasonal))
  }
  if (trunc.pi){
    which.pi <- which(abs(Pi) >= trunc.at)
    if (length(which.pi) == 0) {
      return(numeric(0))
    }
    if (max(which.pi) == lag.max.tot) {
      warning("all ", lag.max.tot, " pi weights retained")
    } else {
      Pi <- Pi[1:max(which.pi)]
    }
  }
  Pi
}

if(FALSE) {  # test inversion
  arma2pi(ma = arma2psi(ar=c(.2,.2)))
  arma2psi(ar = arma2pi(ma=c(-.2,-.2)))

  arma2pi(ma = arma2psi(ar=c(.45,.45)))
  arma2psi(ar = arma2pi(ma=c(-.45,-.45)))

  arma2pi(ma = arma2psi(ar=c(.499,.499)))  # nearly non-stationary
  arma2psi(ar = arma2pi(ma=c(-.499,-.499)))  # nearly non-invertible

}



##
## Rough version of prediction function
##

#'
#' Utility functions
#'
#' Model matrix and response from Arima model on new data
#'
#' This is Arima without calls to arima as a quick fix
#' to get the model.matrix for new data without calling
#' arima which may return an error if it can't fit
#' the model on the new data.
#'
#' This is a quick fix. I realize there are better ways to do this.
#'
getArimaObjects <-
  function(formula, data,
           order = c(1L, 0L, 0L),
           seasonal = list(order = c(0L, 0L, 0L), period = NA),
           ...){
    if (!inherits(data, "ts_data_frame")) {
      data <- as.ts(data)
      message("Note: 'data' coerced to 'ts_data_frame'")
    }
    tsp <- tsp(data[, 1L])
    dots <- list(...)
    cl <- match.call()
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$na.action <- na.pass
    mf[[1L]] <- quote(stats::model.frame)
    mf <- eval(mf, parent.frame())
    mt <- attr(mf, "terms")
    x <- model.matrix(mt, mf)
    which.int <- which("(Intercept)" == colnames(x))
    if (length(which.int > 0)) {
      has.intercept <- TRUE
      x <- x[, -which.int, drop=FALSE]
    } else {
      has.intercept <- FALSE
    }
    result <- list(formula=formula, data=data,
                   order=order, seasonal=seasonal,
                   call=cl, model=mf, dots=dots)
    if (length(formula) == 2L){
      if (!(ncol(x) == 1L) && is.numeric(x[, 1L]))
        stop("formula must specify a single response")
      response <- x[, 1L]
      if (!is.ts(response)) {
        tsp(response) <- tsp
        class(response) <- c("tsp", class(response))
      }
      #result$arima <- stats::arima(response, order=order, seasonal=seasonal,
      #                             ...)
      result$response <- response
    } else {
      y <- model.response(mf, "numeric")
      if (!(is.vector(y) || is.ts(y)) && is.numeric(y))
        stop("formula must specify a single response")
      if (!is.ts(y)) {
        tsp(y) <- tsp
        class(y) <- c("tsp", class(y))
      }
#      result$arima <- stats::arima(y, order=order, seasonal=seasonal, xreg=x,
#                                   include.mean=has.intercept, ...)
      result$response <- y
      result$model.matrix <- x
    }
    class(result) <- "ARIMA"
    result
  }

#' Prediction with ARIMA model
#'
#' Prediction using future (n.ahead) values for predictors
#' and leadup values for response and xvalues for differencing
#'
#' @param model Arima model fit with cv::Arima.
#' @param newdata a data frame with variables whose names are the
#'        same as the variables used as predictiors and
#'        response in the call to cv.Arima. The first 'n.leadup'
#'        rows contain values for the predictor variables
#'        and the response for time points immediately preceding
#'        the time points to be predicted. This is followed by
#'        n.ahead rows with data for predictor values and
#'        NA's for the response value.
#'        If the model used differencing, either ordinary (of
#'        order 'd' with period 1) and/or seasonal with order 'D' with period P,
#'        then number of n.leadup rows must be at least
#'        d + D*P to allow differencing of the predictors
#'        for use in the underlying ARMA model.
#'        In future versions, it will be possible to provide
#'        leadup predictors and responses separately (with
#'        possibly different lengths) and to
#'        provide values of predictors for n.ahead predictions
#'        using either a data frame or a matrix if the values
#'        are 'pre-differenced' if a model uses differencing.
#'
#'  @return A data frame similar to 'newdata' with predicted
#'          responses replacing the NA's for the response, along with a
#'          new variable named '_predicted_' with the
#'          value 'TRUE' in each row in which the response
#'          has been predicted.
#' @export
pred <- function(model, newdata, demean = FALSE, differenced = FALSE) {
  #
  # Future arguments for method: n.ahead = NA, xregnew, differenced = FALSE
  #
  # Changes from previous version:
  #
  # -  Removed constraints requiring multiples of period
  #
  # Rough version function to see if the idea works
  #
  # Prediction with new predictors, Xs, and a sequence of
  # 'lead-up' response values, Ys, preceding the predicted values
  # requires predictor values for the lead-up sequence as
  # well as for the values to be predicted.
  #
  # 'newdata' is a data.frame similar to the data frame
  # used to fit the 'model'.  It consists of
  # n.leadup row with values for Xs and Y
  # followed by n.ahead rows with values for Xs
  # and NA's for Y.
  #
  # n.leadup must be long enough so that ordinary
  # and seasonal differencing to the order in 'model'
  # leaves enough observations for accurate prediction
  # using the ARMA model for the differenced series.
  # The accuracy of prediction will depend on the
  # invertibility of the estimated process.
  #
  # The function computes predicted values for the Ys
  # that are missing by:
  #
  # 1. Getting the model matrix and the response
  #    vector corresponding to 'newdata' using
  #    the model.
  # 2. Differencing the new model matrix and response
  #    as in 'model'
  # 3. Using the resulting ARMA sequence to predict
  #    n.ahead ARMA Ys using pi weights on the
  #    differenced Ys and Xs.
  # 4. Undifferencing the result, including the
  #    leadup data to get predictions on the original
  #    scale for Ys.
  # The function returns the vector of predicted
  # values and the new data frame with leadup and
  # predicted values.
  #
  # Note that, for cross-validation, this approach can use
  # a model that omits an internal fold but the 'leadup'
  # data precedes the predicted values.  The method
  # does not use distant future data to predict the near future
  # but it can use distant future data to estimate the
  # coefficients used to predict the near future.

  #
  # Get y and xreg matrix from new Ys and xreg
  #
  # model_new <- update(model, data = ts_data_frame(newdata)) # produced errors from arima
  model_new <- getArimaObjects(formula(model), data = ts_data_frame(newdata))
  xreg_new <- model.matrix(model_new)                           # FIX if no XREG
  y_new <- model_new$response

  diff_order <- model$order[2]
  seasonal_diff_order <- model$seasonal$order[2]

  n.leadup <- sum(!is.na(y_new))
  n.ahead <- sum(is.na(y_new))

  ##FIXME: following use truncation of leadup data with a warning
  ##       and extension of prediction xreg followed by truncation

  # if(seasonal_diff_order > 0) {
  #   if((sum(!is.na(y_new)) %% seasonal_diff_order) != 0 ){
  #
  #     stop('Number of lead-up data rows should be a multiple of seasonal differencing order (',
  #          seasonal_diff_order,')')
  #   }
  #   if((sum(is.na(y_new)) %% seasonal_diff_order) != 0 ) {
  #     stop('Number of predicted data rows should be a multiple of seasonal differencing order (',
  #          seasonal_diff_order,')')
  #   }
  # }

  coefs <- coef(model)

  if ("(Intercept)" %in% names(coefs)){   # from cv::Predict.ARIMA
    xreg_new <- if (!is.null(xreg_new)){
      cbind(1, xreg_new)
    } else {
      matrix(1, nrow=length(y_new), ncol=1)
    }
  }
  ar <- coefs[grepl('^ar[0-9]+$',names(coefs))]
  ma <- coefs[grepl('^ma[0-9]+$',names(coefs))]
  sar <- coefs[grepl('^sar[0-9]+$',names(coefs))]
  sma <-  coefs[grepl('^sma[0-9]+$',names(coefs))]
  beta <- coefs[-seq_len(length(ar) + length(ma) + length(sar) + length(sma))]

  # Get differenced Ys and xreg

  y_new_diff <- y_new
  xreg_new_diff <- xreg_new

  if(model$seasonal$order[2] > 0) {
    # stopifnot(length(y_new) %% model$seasonal$period == 0)
    # stopifnot(sum(is.na(y_new)) %% model$seasonal$period == 0)
    y_new_diff <- Diff(y_new_diff,
                       seasonal = model$seasonal$order[2],
                       period = model$seasonal$period)
    if(!differenced) xreg_new_diff <- Diff(xreg_new_diff,
                                           seasonal = model$seasonal$order[2],
                                           period = model$seasonal$period)
  }
  if(model$order[2] > 0) {
    y_new_diff <- Diff(y_new_diff,
                       order = model$order[2])
    if(!differenced) xreg_new_diff <- Diff(xreg_new_diff,
                                           order = model$order[2])
  }

  # Residualize differenced Ys

  y_new_res <- y_new_diff - if(!is.null(xreg_new_diff)) xreg_new_diff %*% beta else 0

  #
  # Demean differenced Y ????
  #

  if(demean) {
    mean_y_new_res <- mean(y_new_res, na.rm = T)
    y_new_res <- y_new_res - mean_y_new_res
  }

  # Pi weights

  Pi <- arma2pi(ar = ar, ma = ma)

  convolve <- function(y, w) {
    yrev <- rev(y)
    len <- min(length(y),length(w))
    sum(yrev[1:len]*w[1:len])
  }

  topred <- which(is.na(y_new_res))

  for(i in topred) y_new_res[i] <- convolve(y_new_res[1:(i-1)], Pi)

  new_pred <- y_new_res + {
    if(demean) mean_y_new_res else 0
  } + {
    if(!is.null(beta)) xreg_new_diff %*% beta else 0
  }
  y_new_diff[topred] <- new_pred[topred]  # to keep diff attributes

  if(diff_order > 0 || seasonal_diff_order > 0){
    y_pred <- Diffinv(y_new_diff)
  } else {
    y_pred <- y_new_diff
  }

  newdata[[as.character(model$call$formula[[2]])]] <- y_pred
  newdata$.predicted <- rep(c(FALSE,TRUE), c(nrow(newdata) - sum(is.na(y_new)), sum(is.na(y_new))))
  attr(newdata,'Pi') <- Pi
  attr(newdata,'Mod') <- Mod(polyroot(c(1, -Pi)))
  newdata
}




IF(FALSE){  # testing pred

  library(car)

  Lake <- data.frame(level = LakeHuron, year = time(LakeHuron))
  Lake[] <- lapply(Lake, as.vector)        # to avert problems with rbind, merge

  #
  ## ARMA(2,1) model ############
  #

  # using Arima

  lake.Arima <- Arima(level ~ I(year - 1920), data=Lake,
                      order=c(2, 0, 1))
  newxregdf <- data.frame(year = 1973:1980)

  pred.Arima <- predict(lake.Arima, n.ahead = 8, newdata = newxregdf)

  # using arima

  xreg <- with(Lake, cbind(1, year - 1920))
  lake.arima <- with(Lake, arima(level, xreg = xreg, order = c(2, 0, 1 ),
                                 include.mean = FALSE))
  newxreg <- cbind(1, 1973:1980 - 1920)
  pred.arima <- predict(lake.arima, n.ahead = 8, newxreg = newxreg)
  pred.arima

  # Using pred to predict future observations with lake.Arima

  newdata <- rbind(Lake, data.frame(level = NA, year = 1973:1980))

  preddata <- pred(lake.Arima, newdata, demean = FALSE) # not demeaning ARMA residuals
  preddata2 <- pred(lake.Arima, newdata, demean = TRUE)

  preddata[] <- lapply(preddata, as.vector)

  preddata$source <- ifelse(preddata$.predicted, 'pred not demeaned', 'data')
  preddata2$source <- ifelse(preddata2$.predicted, 'pred demeaned', 'data')

  # Comparing with predict.Arima and predict.arima

  preds <- merge(preddata, preddata2, all = TRUE)
  preds <- merge(
    preds,
    data.frame(
      year = 1973:1980,
      level = as.vector(pred.Arima),
      source = 'predict.Arima'
    ),
    all = TRUE
  )
  preds <- merge(
    preds,
    data.frame(
      year = 1973:1980,
      level = as.vector(pred.arima$pred),
      source = 'predict.arima'
    ),
    all = TRUE
  )
  preds <- subset(preds, year %in% 1973:1980)

  preds$ref <- with(preds,
                    ave(level * (source == 'predict.arima'), factor(year), FUN = function(x) sum(x, na.rm = T))
  )
  preds$difference <- with(preds, level - ref)

  xyplot(level ~ year, preds, groups = source,
         auto.key = TRUE, par.settings = list(superpose.symbol = list(pch = 0:5)))

  xyplot(difference ~ year, preds, groups = source,
         auto.key = TRUE, par.settings = list(superpose.symbol = list(pch = 0:5)))

  # Remarks:
  #
  # - predict.arima and predict.Arima produce identical predictions
  # - Using raw residuals in pred produces a results that are closer to
  #   predict.arima and predict.Arima by a factor of 10 compared
  #   with using demeaned residuals and restoring the means afterwards.
  #


  #
  ## ARIMA(2,1, 1) model ####
  #

  # using Arima

  Lake$clevel <- cumsum(Lake$level)
  lake.Arima <- Arima(clevel ~ I(year - 1920), data=Lake,
                      order=c(2, 1, 1))
  newxregdf <- data.frame(year = 1973:1980)

  pred.Arima <- predict(lake.Arima, n.ahead = 8, newdata = newxregdf)

  # using arima

  xreg <- with(Lake, cbind( year - 1920))
  lake.arima <- with(Lake, arima(clevel, xreg = xreg, order = c(2, 1, 1 ),
                                 include.mean = FALSE))
  newxreg <- cbind(1973:1980 - 1920)
  pred.arima <- predict(lake.arima, n.ahead = 8, newxreg = newxreg)
  pred.arima

  # Using pred to predict future observations with lake.Arima

  newdata <- merge(Lake, data.frame(clevel = NA, year = 1973:1980), all = TRUE)

  preddata <- pred(lake.Arima, newdata, demean = FALSE) # not demeaning ARMA residuals
  preddata2 <- pred(lake.Arima, newdata, demean = TRUE)

  preddata[] <- lapply(preddata, as.vector)

  preddata$source <- ifelse(preddata$.predicted, 'pred not demeaned', 'data')
  preddata2$source <- ifelse(preddata2$.predicted, 'pred demeaned', 'data')

  # Comparing with predict.Arima and predict.arima

  preds <- merge(preddata, preddata2, all = TRUE)
  preds <- merge(
    preds,
    data.frame(
      year = 1973:1980,
      clevel = as.vector(pred.Arima),
      source = 'predict.Arima'
    ),
    all = TRUE
  )
  preds <- merge(
    preds,
    data.frame(
      year = 1973:1980,
      clevel = as.vector(pred.arima$pred),
      source = 'predict.arima'
    ),
    all = TRUE
  )
  preds <- subset(preds, year %in% 1973:1980)

  preds$ref <- with(preds,
                    ave(clevel * (source == 'predict.arima'), factor(year), FUN = function(x) sum(x, na.rm = T))
  )
  preds$difference <- with(preds, clevel - ref)

  xyplot(difference ~ year, preds, groups = source,
         auto.key = TRUE, par.settings = list(superpose.symbol = list(pch = 0:5)))

  preds

  #
  # Remarks:
  #
  # - predict.arima and predict.Arima produce identical predictions
  # - Using raw residuals in pred produces results that are closer to
  #   predict.arima and predict.Arima by a factor of 10 compared
  #   with using demeaned residuals and restoring the means afterwards.
  #

  #
  ## ARIMA(2,0, 1) with decadal differencing  ####
  #

  # using Arima

  Lake$clevel <- diffinv(Lake$level, lag = 10)[-(1:10)]
  lake.Arima <- Arima(clevel ~ I(year - 1920), data=Lake,
                      order=c(2, 0, 1),
                      seasonal = list(order = c(0,1,0), period = 10))
  newxregdf <- data.frame(year = 1973:1980)

  pred.Arima <- predict(lake.Arima, n.ahead = 8, newdata = newxregdf)

  # using arima

  xreg <- with(Lake, cbind( year - 1920))
  lake.arima <- with(Lake, arima(clevel, xreg = xreg,
                                 order = c(2, 0, 1 ),
                                 seasonal = list(order = c(0,1,0), period = 10),
                                 include.mean = FALSE))
  newxreg <- cbind(1973:1980 - 1920)
  pred.arima <- predict(lake.arima, n.ahead = 8, newxreg = newxreg)
  pred.arima

  # Using pred to predict future observations with lake.Arima

  newdata <- merge(Lake, data.frame(clevel = NA, year = 1973:1980), all = TRUE)

  preddata <- pred(lake.Arima, newdata, demean = FALSE) # not demeaning ARMA residuals
  preddata2 <- pred(lake.Arima, newdata, demean = TRUE)

  preddata[] <- lapply(preddata, as.vector)

  preddata$source <- ifelse(preddata$.predicted, 'pred not demeaned', 'data')
  preddata2$source <- ifelse(preddata2$.predicted, 'pred demeaned', 'data')

  # Comparing with predict.Arima and predict.arima

  preds <- merge(preddata, preddata2, all = TRUE)
  preds <- merge(
    preds,
    data.frame(
      year = 1973:1980,
      clevel = as.vector(pred.Arima),
      source = 'predict.Arima'
    ),
    all = TRUE
  )
  preds <- merge(
    preds,
    data.frame(
      year = 1973:1980,
      clevel = as.vector(pred.arima$pred),
      source = 'predict.arima'
    ),
    all = TRUE
  )
  preds <- subset(preds, year %in% 1973:1980)

  preds$ref <- with(preds,
                    ave(clevel * (source == 'predict.arima'), factor(year), FUN = function(x) sum(x, na.rm = T))
  )
  preds$difference <- with(preds, clevel - ref)

  xyplot(difference ~ year, preds, groups = source,
         auto.key = TRUE, par.settings = list(superpose.symbol = list(pch = 0:5)))

  preds
  #
  # Remarks:
  #
  # As in previous examples:
  # - predict.arima and predict.Arima produce identical predictions
  # - Using raw residuals in pred produces a results that are closer to
  #   predict.arima and predict.Arima by a factor of 10 compared
  #   with using demeaned residuals and restoring the means afterwards.
  #

  ## Using pred to predict with new lead-up data ####

  #
  ## ARMA(2,1) model ############
  #


  Lake$clevel <- NULL

  lake.Arima <- Arima(level ~ I(year - 1920), data=Lake,
                      order=c(2, 0, 1))

  pred_df <- subset(Lake, year %in% 1934:1940)
  pred_df$level[(nrow(pred_df) - 5):nrow(pred_df)] <- NA
  preddata1 <- pred(lake.Arima, pred_df, demean = FALSE)
  xyplot(level ~ year, preddata1, groups = .predicted, auto.key = T)

  pred_df <- subset(Lake, year %in% 1921:1940)
  pred_df$level[(nrow(pred_df) - 5):nrow(pred_df)] <- NA
  preddata2 <- pred(lake.Arima, pred_df, demean = FALSE)
  xyplot(level ~ year, preddata2, groups = .predicted, auto.key = T)

  pred_df <- subset(Lake, year %in% 1911:1940)
  pred_df$level[(nrow(pred_df) - 5):nrow(pred_df)] <- NA
  preddata3 <- pred(lake.Arima, pred_df, demean = FALSE)
  xyplot(level ~ year, preddata3, groups = .predicted, auto.key = T)

  pred_df <- subset(Lake, year %in% 1911:1940)
  pred_df$level[(nrow(pred_df) - 12):nrow(pred_df)] <- NA
  preddata3 <- pred(lake.Arima, pred_df, demean = FALSE)
  xyplot(level ~ year, preddata3, groups = .predicted, auto.key = T)

  ## Higher order AR

  lake.Arima4 <- Arima(level ~ I(year - 1920), data=Lake,
                      order=c(1, 0, 0))
  preddata4 <- pred(lake.Arima4, pred_df, demean = FALSE)
  xyplot(level ~ year, preddata4, groups = .predicted, auto.key = T)

}





