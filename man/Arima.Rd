% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv-timeseries.R
\name{Arima}
\alias{Arima}
\alias{print.ARIMA}
\alias{summary.ARIMA}
\alias{print.summary.ARIMA}
\alias{plot.ARIMA}
\alias{Anova.ARIMA}
\alias{linearHypothesis.ARIMA}
\alias{testArima}
\alias{testArima.ARIMA}
\alias{update.ARIMA}
\alias{coef.ARIMA}
\alias{vcov.ARIMA}
\alias{logLik.ARIMA}
\alias{AIC.ARIMA}
\alias{model.matrix.ARIMA}
\alias{model.frame.ARIMA}
\alias{fitted.ARIMA}
\alias{residuals.ARIMA}
\alias{predict.ARIMA}
\alias{cv.ARIMA}
\alias{as.ts.data.frame}
\alias{ts_data_frame}
\alias{as.ts.ts_data_frame}
\alias{window.ts_data_frame}
\alias{time.ts_data_frame}
\title{Fit and Cross-Validate ARIMA Models}
\usage{
Arima(
  formula,
  data,
  order = c(1L, 0L, 0L),
  seasonal = list(order = c(0L, 0L, 0L), period = NA),
  ...
)

\method{print}{ARIMA}(x, digits = max(3L, getOption("digits") - 3L), ...)

\method{summary}{ARIMA}(object, correlation = FALSE, ...)

\method{print}{summary.ARIMA}(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

\method{plot}{ARIMA}(x, ...)

\method{Anova}{ARIMA}(mod, type = c("II", "III", 2, 3), ...)

\method{linearHypothesis}{ARIMA}(model, hypothesis.matrix, rhs = NULL, ...)

testArima(model, ...)

\method{testArima}{ARIMA}(
  model,
  lag = floor(10 * log10(n)),
  type = c("Box-Pierce", "Ljung-Box"),
  ...
)

\method{update}{ARIMA}(object, formula, ...)

\method{coef}{ARIMA}(object, ...)

\method{vcov}{ARIMA}(object, ...)

\method{logLik}{ARIMA}(object, ...)

\method{AIC}{ARIMA}(object, ..., k)

\method{model.matrix}{ARIMA}(object, ...)

\method{model.frame}{ARIMA}(formula, ...)

\method{fitted}{ARIMA}(object, ...)

\method{residuals}{ARIMA}(object, ...)

\method{predict}{ARIMA}(object, n.ahead, newdata = NULL, se.fit = FALSE, ...)

\method{cv}{ARIMA}(
  model,
  data = model$data,
  criterion = mse,
  k = if (fold.type == "preceding") 10L else "n",
  reps,
  seed,
  fold.type = c("window", "cumulative", "preceding"),
  begin.with = max(25, ceiling(n/10)),
  lead = 1L,
  min.ahead = 1L,
  criterion.name = deparse(substitute(criterion)),
  details = n <= 10000,
  ncores = 1L,
  ...
)

\method{as.ts}{data.frame}(x, start = 1L, end, frequency = 1L, ...)

ts_data_frame(..., start, end, frequency)

\method{as.ts}{ts_data_frame}(x, ...)

\method{window}{ts_data_frame}(x, start = NULL, end = NULL, ...)

\method{time}{ts_data_frame}(x, ...)
}
\arguments{
\item{formula}{either a one-sided formula giving the response variable
in an ARIMA model with no predictors, or a two-sided formula with the
response on the left and terms for the predictors on the right (as in
a typical R regression model); if the timeseries is differenced, the intercept
is removed from the model even if the formula implies an intercept.
For the \code{\link[stats]{model.frame}()}
method (to match the generic), an \code{"ARIMA"} object.}

\item{data}{time-series data frame with the data to which the model was fit;
can usually be inferred from the model; for \code{Arima()}, a time-series data
frame with data to which the model is to be fit. \code{data} must be
a time-series data frame, i.e., a \code{"ts_data_frame"} object, whose
columns are each \code{\link[stats]{ts}} objects with common times; if it
is not, an attempt will be made to coerce it to a  \code{"ts_data_frame"} object
by \code{as.ts.data.frame()}.}

\item{order}{the \eqn{p, d, q} specification of the ARIMA model;
see \code{\link{arima}()} for details; the default is \eqn{p = 1, d = 0, q = 0},
an AR(1) model.}

\item{seasonal}{specification of the seasonal part of the ARIMA model;
see \code{\link{arima}()} for details; the default is not to include
a seasonal part of the model.}

\item{...}{further arguments to be passed to \code{\link{arima}()},
\code{Arima()}, or other functions and methods; for \code{ts_data_frame()},
arguments to be passed to \code{\link{data.frame}()}, typically the
variables to constitute the \code{"ts_data_frame"} object.}

\item{x}{an object of class \code{"ARIMA"}.}

\item{digits}{for printing.}

\item{object}{an object of class \code{"ARIMA"}.}

\item{correlation}{compute and report correlations of coefficients.}

\item{signif.stars}{show "significance stars" in coefficient table?}

\item{mod}{an object of class \code{"ARIMA"}
produced by the \code{Arima()} function.}

\item{type}{test of autocorrelations, either \code{"Box-Pierce"} (the default)
or \code{"Ljung-Box"} (see \code{\link[stats]{Box.test}()});
for the \code{Anova()}, method, "type" of test (see \code{\link[car]{Anova}()}
for details.)}

\item{model}{an object of class \code{"ARIMA"}
produced by the \code{Arima()} function.}

\item{hypothesis.matrix}{specification of the linear hypothesis;
for details, see \code{\link[car]{linearHypothesis}()}.}

\item{rhs}{optional right-hand-side vector for the linear hypothesis;
for details, see \code{\link[car]{linearHypothesis}()}.}

\item{lag}{maximum lag to compute residual autocorrelation; if not
specified, the same default maximum lag as \code{\link[stats]{acf}}
is used.}

\item{k}{number of folds, an integer \eqn{\gt 2}; the default value of \code{k} depends on
\code{fold.type};  if \code{k = "n"},
the first fold is determined by \code{begin.with} and subsequent folds
each contain a single case; that makes sense if \code{fold.type = "cumulative"}.
Ignored for the \code{ATC()} method (to match the generic).}

\item{n.ahead}{number of future cases to predict.}

\item{newdata}{data frame with rows containing the
predictors (if any) for predicted future cases.}

\item{se.fit}{if \code{TRUE} (the default is \code{FALSE}), compute
the standard errors of the predictions.}

\item{criterion}{function to compute the CV cost criterion
(default \code{\link{mse}}).}

\item{reps}{ignored (to match \code{\link{cv}()} generic function).}

\item{seed}{ignored (to match \code{\link{cv}()} generic function).}

\item{fold.type}{if \code{"window"} (the default), folds comprise a moving window
of \code{begin.with} cases; if \code{"cumulative"}, predict
the response for 1 or more cases after the i-th fold from the model fit to data
in the \code{i}th and all preceding folds; if \code{"preceding"}, predict using cases in
the \code{i}th fold only.}

\item{begin.with}{the number of cases in
the first fold; disregarded for \code{fold.type="preceding"}.
The remaining cases are divided among the subsequent
\code{k} - 1 folds.}

\item{lead}{how far ahead to predict (can be a vector of positive integers);
the default is \code{1}.}

\item{min.ahead}{the minimum number of "future" cases to include in
the last fold (default \code{1}); more than one case may be required for
some kinds of predictions for terms with data-dependent bases, such as those using
\code{\link[stats]{poly}()} (orthogonal polynomials).}

\item{criterion.name}{name of the CV criterion; can usually be
inferred from \code{criterion}.}

\item{details}{return fold-wise parameter estimates for cases in each fold after the first;
the default is \code{TRUE} for \eqn{k \le 10,000}.}

\item{ncores}{if \code{ncores} \eqn{> 1}, the computation is parallelized.}

\item{start}{the beginning time (see \code{link[stats]{ts}()}).}

\item{end}{the ending time (can be inferred from the data,
see \code{link[stats]{ts}()}).}

\item{frequency}{the period of the time series (e.g., \code{4}
for quarterly data, see \code{link[stats]{ts}()}).}
}
\value{
the \code{\link{cv.ARIMA}()} method returns an object of class
\code{c("cvOrdered", "cv")} (see  \code{\link{cvOrdered}()} and \code{\link{cv}()}).

\code{Arima()} returns an object of class \code{"ARIMA"} with the
following components: \code{formula}, the model formula; \code{data},
the data set to which the model was fit;
\code{order}, the order of the ARIMA model;
\code{seasonal}, the seasonal specification;
\code{call}, the function call;
\code{dots}, any other arguments specified; \code{arima},
the object returned by the \code{\link{arima}()} function,
which \code{Arima()} calls;
\code{response}, the response variable; \code{model.matrix},
the model matrix, if there are predictors in the model.
}
\description{
\code{\link{cv}()} methods for time-series models
fit by \code{Arima()}, which provides a formula interface to the
\code{\link{arima}()}) function.
}
\section{Functions}{
\itemize{
\item \code{Arima()}: model-formula wrapper for the \code{\link{arima}()} function.

\item \code{print(ARIMA)}: \code{print()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{summary(ARIMA)}: \code{summary()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{print(summary.ARIMA)}: \code{print()} method for \code{"summary.ARIMA"} objects.

\item \code{plot(ARIMA)}: \code{plot()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function; calls \code{\link[stats]{tsdiag}()}.

\item \code{Anova(ARIMA)}: \code{\link[car]{Anova}()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{linearHypothesis(ARIMA)}: \code{\link[car]{linearHypothesis}()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{testArima(ARIMA)}: test autocorrelations of ARIMA model residuals;
the test is performed by \code{\link[stats]{Box.test}()}.

\item \code{update(ARIMA)}: \code{update()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{coef(ARIMA)}: \code{coef()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{vcov(ARIMA)}: \code{vcov()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{logLik(ARIMA)}: \code{logLik()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{AIC(ARIMA)}: \code{AIC()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{model.matrix(ARIMA)}: \code{model.matrix()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{model.frame(ARIMA)}: \code{model.frame()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{fitted(ARIMA)}: \code{fitted()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{residuals(ARIMA)}: \code{residuals()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{predict(ARIMA)}: \code{predict()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{cv(ARIMA)}: \code{cv()} method for \code{"ARIMA"} objects
created by the \code{\link{Arima}()} function.

\item \code{as.ts(data.frame)}: \code{as.ts()} method for \code{"data.frame"} objects;
produces an object of class \code{"ts_data_frame"} inheriting from \code{"data.frame"}.

\item \code{ts_data_frame()}: constructor function for \code{"ts_data_frame"} objects.

\item \code{as.ts(ts_data_frame)}: \code{as.ts()} method for \code{"ts_data_frame"} objects;
returns the object unchanged.

\item \code{window(ts_data_frame)}: \code{window()} method for \code{"ts_data_frame"} objects;
returns a subset of the object, also a \code{"ts_data_frame"}, with correctly subsetted \code{"ts"}
objects as columns.

\item \code{time(ts_data_frame)}: \code{time()} method for \code{"ts_data_frame"} objects;
returns the (common) times associated with the columns of the \code{"ts_data_frame"}.

}}
\examples{
if (require("stats", quietly=TRUE) &&
    require("datasets", quietly=TRUE) &&
    require(splines) &&
    require("car") &&
    require("effects")){
withAutoprint({
# model adapted from help("arima")
LH <- data.frame(lh = lh)
lh.arima <- Arima(~lh, data=LH)
summary(lh.arima)
plot(lh.arima)
testArima(lh.arima)
summary(cv.lh <- cv(lh.arima, lead=1:5))
plot(cv.lh)
summary(cv(lh.arima, lead=1:5, fold.type="window"))
# too few folds (5), just to illustrate fold.type="preceding":
summary(cv(lh.arima, k=5, fold.type="preceding"))

# model adapted from help("arima")
Lake <- ts_data_frame(level=LakeHuron, year=time(LakeHuron))
lake.arima <- Arima(level ~ I(year - 1920), data=Lake,
                  order=c(2, 0, 0))
summary(lake.arima)
Anova(lake.arima, type=3)
linearHypothesis(lake.arima, hypothesis=c("ar1", "ar2"))
plot(lake.arima)
testArima(lake.arima)
summary(cv.lake <- cv(lake.arima, lead=1:5))
plot(cv.lake)
plot(Effect("year", lake.arima, residuals=TRUE))
lake.arima.bs <- update(lake.arima, . ~ ns(year, 3))
summary(cv(lake.arima.bs, lead=1:5))
plot(Effect("year", lake.arima.bs, residuals=TRUE))
lake.arima.quad <- update(lake.arima, . ~ poly(year, 2))
summary(cv(lake.arima.quad, lead=1:5, min.ahead=3))
plot(Effect("year", lake.arima.quad, residuals=TRUE))
plot(cv(models(linear = lake.arima,
               bspline = lake.arima.bs,
               quadratic = lake.arima.quad),
        lead=1:5, min.ahead=3, data=Lake))
})
}
}
