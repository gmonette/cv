<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Computational and technical notes on cross-validating regression models • cv</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Computational and technical notes on cross-validating regression models">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">cv</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">2.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/cv.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/cv-extend.html">Extending the cv package</a></li>
    <li><a class="dropdown-item" href="../articles/cv-mixed.html">Cross-validating mixed-effects models</a></li>
    <li><a class="dropdown-item" href="../articles/cv-notes.html">Computational and technical notes on cross-validating regression models</a></li>
    <li><a class="dropdown-item" href="../articles/cv-selection.html">Cross-validating model selection</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/gmonette/cv/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Computational and technical notes on cross-validating regression models</h1>
                        <h4 data-toc-skip class="author">John Fox and
Georges Monette</h4>
            
            <h4 data-toc-skip class="date">2024-07-14</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/gmonette/cv/blob/main/vignettes/cv-notes.Rmd" class="external-link"><code>vignettes/cv-notes.Rmd</code></a></small>
      <div class="d-none name"><code>cv-notes.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="efficient-computations-for-linear-and-generalized-linear-models">Efficient computations for linear and generalized linear models<a class="anchor" aria-label="anchor" href="#efficient-computations-for-linear-and-generalized-linear-models"></a>
</h2>
<p>The most straightforward way to implement cross-validation in R for
statistical modeling functions that are written in the canonical manner
is to use <code><a href="https://rdrr.io/r/stats/update.html" class="external-link">update()</a></code> to refit the model with each fold
removed. This is the approach taken in the default method for
<code><a href="../reference/cv.html">cv()</a></code>, and it is appropriate if the cases are independently
sampled. Refitting the model in this manner for each fold is generally
feasible when the number of folds in modest, but can be prohibitively
costly for leave-one-out cross-validation when the number of cases is
large.</p>
<p>The <code>"lm"</code> and <code>"glm"</code> methods for
<code><a href="../reference/cv.html">cv()</a></code> take advantage of computational efficiencies by
avoiding refitting the model with each fold removed. Consider, in
particular, the weighted linear model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐲</mi><mrow><mi>n</mi><mo>×</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>𝐗</mi><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow></msub><msub><mi>𝛃</mi><mrow><mi>p</mi><mo>×</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>𝛆</mi><mrow><mi>n</mi><mo>×</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{y}_{n \times 1} = \mathbf{X}_{n \times p}\boldsymbol{\beta}_{p \times 1} + \boldsymbol{\varepsilon}_{n \times 1}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛆</mi><mo>∼</mo><msub><mi>𝐍</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>𝟎</mn><mo>,</mo><msup><mi>σ</mi><mn>2</mn></msup><msubsup><mi>𝐖</mi><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{\varepsilon} \sim \mathbf{N}_n \left(\mathbf{0}, \sigma^2 \mathbf{W}^{-1}_{n \times n}\right)</annotation></semantics></math>.
Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math>
is the response vector,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
the model matrix, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛆</mi><annotation encoding="application/x-tex">\boldsymbol{\varepsilon}</annotation></semantics></math>
the error vector, each for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
cases, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math>
is the vector of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
population regression coefficients. The errors are assumed to be
multivariately normally distributed with 0 means and covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><msup><mi>𝐖</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\sigma^2 \mathbf{W}^{-1}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>=</mo><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{W} = \mathrm{diag}(w_i)</annotation></semantics></math>
is a diagonal matrix of inverse-variance weights. For the linear model
with constant error variance, the weight matrix is taken to be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>=</mo><msub><mi>𝐈</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{W} = \mathbf{I}_n</annotation></semantics></math>,
the
order-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
identity matrix.</p>
<p>The weighted-least-squares (WLS) estimator of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math>
is <span class="citation">(see, e.g., Fox, 2016, sec. 12.2.2)</span> <a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;This is a definitional formula, which assumes that the
model matrix
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;𝐗&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;\mathbf{X}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
is of full column rank, and which can be subject to numerical
instability when
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;𝐗&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;\mathbf{X}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
is ill-conditioned. &lt;code&gt;&lt;a href="https://rdrr.io/r/stats/lm.html" class="external-link"&gt;lm()&lt;/a&gt;&lt;/code&gt; uses the singular-value
decomposition of the model matrix to obtain computationally more stable
results.&lt;/p&gt;'><sup>1</sup></a>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐛</mi><mrow><mi mathvariant="normal">W</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">S</mi></mrow></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐖</mi><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐖</mi><mi>𝐲</mi></mrow><annotation encoding="application/x-tex">
\mathbf{b}_{\mathrm{WLS}} = \left( \mathbf{X}^T \mathbf{W} \mathbf{X} \right)^{-1} 
  \mathbf{X}^T \mathbf{W} \mathbf{y}
</annotation></semantics></math></p>
<p>Fitted values are then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mo>=</mo><mi>𝐗</mi><msub><mi>𝐛</mi><mrow><mi mathvariant="normal">W</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\widehat{\mathbf{y}} = \mathbf{X}\mathbf{b}_{\mathrm{WLS}}</annotation></semantics></math>.</p>
<p>The LOO fitted value for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
case can be efficiently computed by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mi>e</mi><mi>i</mi></msub><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\widehat{y}_{-i} = y_i - e_i/(1 - h_i)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><msubsup><mi>𝐱</mi><mi>i</mi><mi>T</mi></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐖</mi><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐱</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i = \mathbf{x}^T_i \left( \mathbf{X}^T \mathbf{W} \mathbf{X} \right)^{-1} \mathbf{x}_i</annotation></semantics></math>
(the so-called “hatvalue”). Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>𝐱</mi><mi>i</mi><mi>T</mi></msubsup><annotation encoding="application/x-tex">\mathbf{x}^T_i</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐱</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
row written as a column vector. This approach can break down when one or
more hatvalues are equal to 1, in which case the formula for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>i</mi></mrow></msub><annotation encoding="application/x-tex">\widehat{y}_{-i}</annotation></semantics></math>
requires division by 0.</p>
<p>To compute cross-validated fitted values when the folds contain more
than one case, we make use of the Woodbury matrix identity <span class="citation">(Hager, 1989)</span>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐀</mi><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow></msub><mo>+</mo><msub><mi>𝐔</mi><mrow><mi>m</mi><mo>×</mo><mi>k</mi></mrow></msub><msub><mi>𝐂</mi><mrow><mi>k</mi><mo>×</mo><mi>k</mi></mrow></msub><msub><mi>𝐕</mi><mrow><mi>k</mi><mo>×</mo><mi>m</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>𝐀</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><msup><mi>𝐀</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐔</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐂</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mrow><mi>𝐕</mi><mi>𝐀</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐔</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mrow><mi>𝐕</mi><mi>𝐀</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
\left(\mathbf{A}_{m \times m} + \mathbf{U}_{m \times k} 
\mathbf{C}_{k \times k} \mathbf{V}_{k \times m} \right)^{-1} = \mathbf{A}^{-1} - \mathbf{A}^{-1}\mathbf{U} \left(\mathbf{C}^{-1} + 
\mathbf{VA}^{-1}\mathbf{U} \right)^{-1} \mathbf{VA}^{-1}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>
is a nonsingular
order-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
matrix. We apply this result by letting
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐀</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐖</mi><mi>𝐗</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐔</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>𝐗</mi><mi>𝐣</mi><mi>T</mi></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐕</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>−</mo><msub><mi>𝐗</mi><mi>𝐣</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐂</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>𝐖</mi><mi>𝐣</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \mathbf{A} &amp;= \mathbf{X}^T \mathbf{W} \mathbf{X} \\
    \mathbf{U} &amp;= \mathbf{X}_\mathbf{j}^T \\
    \mathbf{V} &amp;= - \mathbf{X}_\mathbf{j} \\
    \mathbf{C} &amp;= \mathbf{W}_\mathbf{j} \\
\end{align*}</annotation></semantics></math> where the subscript
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐣</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>i</mi><mrow><mi>j</mi><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>i</mi><mrow><mi>j</mi><mi>m</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{j} = (i_{j1}, \ldots, i_{jm})^T</annotation></semantics></math>
represents the vector of indices for the cases in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>th
fold,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j = 1, \ldots, k</annotation></semantics></math>.
The negative sign in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo>=</mo><mo>−</mo><msub><mi>𝐗</mi><mi>𝐣</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{V} = - \mathbf{X}_\mathbf{j}</annotation></semantics></math>
reflects the <em>removal</em>, rather than addition, of the cases in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐣</mi><annotation encoding="application/x-tex">\mathbf{j}</annotation></semantics></math>.</p>
<p>Applying the Woodbury identity isn’t quite as fast as using the
hatvalues, but it is generally much faster than refitting the model. A
disadvantage of the Woodbury identity, however, is that it entails
explicit matrix inversion and thus may be numerically unstable. The
inverse of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐀</mi><mo>=</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐖</mi><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{A} = \mathbf{X}^T \mathbf{W} \mathbf{X}</annotation></semantics></math>
is available directly in the <code>"lm"</code> object, but the second
term on the right-hand side of the Woodbury identity requires a matrix
inversion with each fold deleted. (In contrast, the inverse of each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>=</mo><msub><mi>𝐖</mi><mi>𝐣</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{C} = \mathbf{W}_\mathbf{j}</annotation></semantics></math>
is straightforward because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>
is diagonal.)</p>
<p>The Woodbury identity also requires that the model matrix be of full
rank. We impose that restriction in our code by removing redundant
regressors from the model matrix for all of the cases, but that doesn’t
preclude rank deficiency from surfacing when a fold is removed. Rank
deficiency of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
doesn’t disqualify cross-validation because all we need are fitted
values under the estimated model.</p>
<p><code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> computes the maximum-likelihood estimates for a
generalized linear model by iterated weighted least squares <span class="citation">(see, e.g., Fox &amp; Weisberg, 2019, sec.
6.12)</span>. The last iteration is therefore just a WLS fit of the
“working response” on the model matrix using “working weights.” Both the
working weights and the working response at convergence are available
from the information in the object returned by <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code>.</p>
<p>We then treat re-estimation of the model with a case or cases deleted
as a WLS problem, using the hatvalues or the Woodbury matrix identity.
The resulting fitted values for the deleted fold aren’t exact—that is,
except for the Gaussian family, the result isn’t identical to what we
would obtain by literally refitting the model—but in our (limited)
experience, the approximation is very good, especially for LOO CV, which
is when we would be most tempted to use it. Nevertheless, because these
results are approximate, the default for the <code>"glm"</code>
<code><a href="../reference/cv.html">cv()</a></code> method is to perform the exact computation, which
entails refitting the model with each fold omitted.</p>
<p>Let’s compare the efficiency of the various computational methods for
linear and generalized linear models. Consider, for example,
leave-one-out cross-validation for the quadratic regression of
<code>mpg</code> on <code>horsepower</code> in the <code>Auto</code>
data, from the introductory “Cross-validating regression models”
vignette, repeated here:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"Auto"</span>, package<span class="op">=</span><span class="st">"ISLR2"</span><span class="op">)</span></span>
<span><span class="va">m.auto</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">mpg</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/poly.html" class="external-link">poly</a></span><span class="op">(</span><span class="va">horsepower</span>, <span class="fl">2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">Auto</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">m.auto</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; lm(formula = mpg ~ poly(horsepower, 2), data = Auto)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residuals:</span></span>
<span><span class="co">#&gt;     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">#&gt; -14.714  -2.594  -0.086   2.287  15.896 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;                      Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">#&gt; (Intercept)            23.446      0.221   106.1   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; poly(horsepower, 2)1 -120.138      4.374   -27.5   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; poly(horsepower, 2)2   44.090      4.374    10.1   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residual standard error: 4.37 on 389 degrees of freedom</span></span>
<span><span class="co">#&gt; Multiple R-squared:  0.688,  Adjusted R-squared:  0.686 </span></span>
<span><span class="co">#&gt; F-statistic:  428 on 2 and 389 DF,  p-value: &lt;2e-16</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://gmonette.github.io/cv/">"cv"</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; Loading required package: doParallel</span></span>
<span><span class="co">#&gt; Loading required package: foreach</span></span>
<span><span class="co">#&gt; Loading required package: iterators</span></span>
<span><span class="co">#&gt; Loading required package: parallel</span></span>
<span><span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.auto</span>, k <span class="op">=</span> <span class="st">"loo"</span><span class="op">)</span>  <span class="co"># default method = "hatvalues"</span></span>
<span><span class="co">#&gt; n-Fold Cross Validation</span></span>
<span><span class="co">#&gt; method: hatvalues</span></span>
<span><span class="co">#&gt; criterion: mse</span></span>
<span><span class="co">#&gt; cross-validation criterion = 19.248</span></span>
<span><span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.auto</span>, k <span class="op">=</span> <span class="st">"loo"</span>, method <span class="op">=</span> <span class="st">"naive"</span><span class="op">)</span></span>
<span><span class="co">#&gt; n-Fold Cross Validation</span></span>
<span><span class="co">#&gt; method: naive</span></span>
<span><span class="co">#&gt; criterion: mse</span></span>
<span><span class="co">#&gt; cross-validation criterion = 19.248</span></span>
<span><span class="co">#&gt; bias-adjusted cross-validation criterion = 19.248</span></span>
<span><span class="co">#&gt; full-sample criterion = 18.985</span></span>
<span><span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.auto</span>, k <span class="op">=</span> <span class="st">"loo"</span>, method <span class="op">=</span> <span class="st">"Woodbury"</span><span class="op">)</span></span>
<span><span class="co">#&gt; n-Fold Cross Validation</span></span>
<span><span class="co">#&gt; method: Woodbury</span></span>
<span><span class="co">#&gt; criterion: mse</span></span>
<span><span class="co">#&gt; cross-validation criterion = 19.248</span></span>
<span><span class="co">#&gt; bias-adjusted cross-validation criterion = 19.248</span></span>
<span><span class="co">#&gt; full-sample criterion = 18.985</span></span></code></pre></div>
<p>This is a small regression problem and all three computational
approaches are essentially instantaneous, but it is still of interest to
investigate their relative speed. In this comparison, we include the
<code><a href="../reference/cv.html">cv.glm()</a></code> function from the <strong>boot</strong> package
<span class="citation">(Canty &amp; Ripley, 2022; Davison &amp; Hinkley,
1997)</span>, which takes the naive approach, and for which we have to
fit the linear model as an equivalent Gaussian GLM. We use the
<code>microbenchmark()</code> function from the package of the same name
for the timings <span class="citation">(Mersmann, 2023)</span>:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.auto.glm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">mpg</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/poly.html" class="external-link">poly</a></span><span class="op">(</span><span class="va">horsepower</span>, <span class="fl">2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">Auto</span><span class="op">)</span></span>
<span><span class="fu">boot</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/boot/man/cv.glm.html" class="external-link">cv.glm</a></span><span class="op">(</span><span class="va">Auto</span>, <span class="va">m.auto.glm</span><span class="op">)</span><span class="op">$</span><span class="va">delta</span></span>
<span><span class="co">#&gt; [1] 19.248 19.248</span></span>
<span></span>
<span><span class="fu">microbenchmark</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html" class="external-link">microbenchmark</a></span><span class="op">(</span></span>
<span>  hatvalues <span class="op">=</span> <span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.auto</span>, k <span class="op">=</span> <span class="st">"loo"</span><span class="op">)</span>,</span>
<span>  Woodbury <span class="op">=</span> <span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.auto</span>, k <span class="op">=</span> <span class="st">"loo"</span>, method <span class="op">=</span> <span class="st">"Woodbury"</span><span class="op">)</span>,</span>
<span>  naive <span class="op">=</span> <span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.auto</span>, k <span class="op">=</span> <span class="st">"loo"</span>, method <span class="op">=</span> <span class="st">"naive"</span><span class="op">)</span>,</span>
<span>  cv.glm <span class="op">=</span> <span class="fu">boot</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/boot/man/cv.glm.html" class="external-link">cv.glm</a></span><span class="op">(</span><span class="va">Auto</span>, <span class="va">m.auto.glm</span><span class="op">)</span>,</span>
<span>  times <span class="op">=</span> <span class="fl">10</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in microbenchmark::microbenchmark(hatvalues = cv(m.auto, k = "loo"), :</span></span>
<span><span class="co">#&gt; less accurate nanosecond times to avoid potential integer overflows</span></span>
<span><span class="co">#&gt; Unit: milliseconds</span></span>
<span><span class="co">#&gt;       expr      min       lq     mean   median       uq      max neval</span></span>
<span><span class="co">#&gt;  hatvalues   1.2453   1.3835   1.6991   1.6146   2.0563   2.3243    10</span></span>
<span><span class="co">#&gt;   Woodbury  14.1367  15.3529  17.9319  16.1360  20.6006  24.6777    10</span></span>
<span><span class="co">#&gt;      naive 288.3592 309.1487 330.2526 318.5020 346.9057 414.0674    10</span></span>
<span><span class="co">#&gt;     cv.glm 501.1039 555.3946 615.5724 573.1612 650.0927 810.8867    10</span></span></code></pre></div>
<p>On our computer, using the hatvalues is about an order of magnitude
faster than employing Woodbury matrix updates, and more than two orders
of magnitude faster than refitting the model.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Out of impatience, we asked
&lt;code&gt;microbenchmark()&lt;/code&gt; to execute each command only 10 times
rather than the default 100. With the exception of the last columns, the
output is self-explanatory. The last column shows which methods have
average timings that are statistically distinguishable. Because of the
small number of repetitions (i.e., 10), the &lt;code&gt;"hatvalues"&lt;/code&gt; and
&lt;code&gt;"Woodbury"&lt;/code&gt; methods aren’t distinguishable, but the
difference between these methods persists when we perform more
repetitions—we invite the reader to redo this computation with the
default &lt;code&gt;times=100&lt;/code&gt; repetitions.&lt;/p&gt;'><sup>2</sup></a></p>
<p>Similarly, let’s return to the logistic-regression model fit to
Mroz’s data on women’s labor-force participation, also employed as an
example in the introductory vignette:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"Mroz"</span>, package<span class="op">=</span><span class="st">"carData"</span><span class="op">)</span></span>
<span><span class="va">m.mroz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">lfp</span> <span class="op">~</span> <span class="va">.</span>, data <span class="op">=</span> <span class="va">Mroz</span>, family <span class="op">=</span> <span class="va">binomial</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">m.mroz</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; glm(formula = lfp ~ ., family = binomial, data = Mroz)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;             Estimate Std. Error z value Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; (Intercept)  3.18214    0.64438    4.94  7.9e-07 ***</span></span>
<span><span class="co">#&gt; k5          -1.46291    0.19700   -7.43  1.1e-13 ***</span></span>
<span><span class="co">#&gt; k618        -0.06457    0.06800   -0.95  0.34234    </span></span>
<span><span class="co">#&gt; age         -0.06287    0.01278   -4.92  8.7e-07 ***</span></span>
<span><span class="co">#&gt; wcyes        0.80727    0.22998    3.51  0.00045 ***</span></span>
<span><span class="co">#&gt; hcyes        0.11173    0.20604    0.54  0.58762    </span></span>
<span><span class="co">#&gt; lwg          0.60469    0.15082    4.01  6.1e-05 ***</span></span>
<span><span class="co">#&gt; inc         -0.03445    0.00821   -4.20  2.7e-05 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; (Dispersion parameter for binomial family taken to be 1)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     Null deviance: 1029.75  on 752  degrees of freedom</span></span>
<span><span class="co">#&gt; Residual deviance:  905.27  on 745  degrees of freedom</span></span>
<span><span class="co">#&gt; AIC: 921.3</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of Fisher Scoring iterations: 4</span></span>
<span></span>
<span><span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.mroz</span>, <span class="co"># default method = "exact"</span></span>
<span>   k <span class="op">=</span> <span class="st">"loo"</span>, </span>
<span>   criterion <span class="op">=</span> <span class="va">BayesRule</span><span class="op">)</span></span>
<span><span class="co">#&gt; n-Fold Cross Validation</span></span>
<span><span class="co">#&gt; method: exact</span></span>
<span><span class="co">#&gt; criterion: BayesRule</span></span>
<span><span class="co">#&gt; cross-validation criterion = 0.32005</span></span>
<span><span class="co">#&gt; bias-adjusted cross-validation criterion = 0.3183</span></span>
<span><span class="co">#&gt; 95% CI for bias-adjusted CV criterion = (0.28496, 0.35164)</span></span>
<span><span class="co">#&gt; full-sample criterion = 0.30677</span></span>
<span><span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.mroz</span>,</span>
<span>   k <span class="op">=</span> <span class="st">"loo"</span>,</span>
<span>   criterion <span class="op">=</span> <span class="va">BayesRule</span>,</span>
<span>   method <span class="op">=</span> <span class="st">"Woodbury"</span><span class="op">)</span></span>
<span><span class="co">#&gt; n-Fold Cross Validation</span></span>
<span><span class="co">#&gt; method: Woodbury</span></span>
<span><span class="co">#&gt; criterion: BayesRule</span></span>
<span><span class="co">#&gt; cross-validation criterion = 0.32005</span></span>
<span><span class="co">#&gt; bias-adjusted cross-validation criterion = 0.3183</span></span>
<span><span class="co">#&gt; 95% CI for bias-adjusted CV criterion = (0.28496, 0.35164)</span></span>
<span><span class="co">#&gt; full-sample criterion = 0.30677</span></span>
<span><span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.mroz</span>,</span>
<span>   k <span class="op">=</span> <span class="st">"loo"</span>,</span>
<span>   criterion <span class="op">=</span> <span class="va">BayesRule</span>,</span>
<span>   method <span class="op">=</span> <span class="st">"hatvalues"</span><span class="op">)</span></span>
<span><span class="co">#&gt; n-Fold Cross Validation</span></span>
<span><span class="co">#&gt; method: hatvalues</span></span>
<span><span class="co">#&gt; criterion: BayesRule</span></span>
<span><span class="co">#&gt; cross-validation criterion = 0.32005</span></span></code></pre></div>
<p>As for linear models, we report some timings for the various
<code><a href="../reference/cv.html">cv()</a></code> methods of computation in LOO CV as well as for the
<code><a href="../reference/cv.html">cv.glm()</a></code> function from the <strong>boot</strong> package
(which, recall, refits the model with each case removed, and thus is
comparable to <code><a href="../reference/cv.html">cv()</a></code> with <code>method="exact"</code>):</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">microbenchmark</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html" class="external-link">microbenchmark</a></span><span class="op">(</span></span>
<span>  hatvalues <span class="op">=</span> <span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span></span>
<span>    <span class="va">m.mroz</span>,</span>
<span>    k <span class="op">=</span> <span class="st">"loo"</span>,</span>
<span>    criterion <span class="op">=</span> <span class="va">BayesRule</span>,</span>
<span>    method <span class="op">=</span> <span class="st">"hatvalues"</span></span>
<span>  <span class="op">)</span>,</span>
<span>  Woodbury <span class="op">=</span> <span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span></span>
<span>    <span class="va">m.mroz</span>,</span>
<span>    k <span class="op">=</span> <span class="st">"loo"</span>,</span>
<span>    criterion <span class="op">=</span> <span class="va">BayesRule</span>,</span>
<span>    method <span class="op">=</span> <span class="st">"Woodbury"</span></span>
<span>  <span class="op">)</span>,</span>
<span>  exact <span class="op">=</span> <span class="fu"><a href="../reference/cv.html">cv</a></span><span class="op">(</span><span class="va">m.mroz</span>, k <span class="op">=</span> <span class="st">"loo"</span>, criterion <span class="op">=</span> <span class="va">BayesRule</span><span class="op">)</span>,</span>
<span>  cv.glm <span class="op">=</span> <span class="fu">boot</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/boot/man/cv.glm.html" class="external-link">cv.glm</a></span><span class="op">(</span><span class="va">Mroz</span>, <span class="va">m.mroz</span>,</span>
<span>                        cost <span class="op">=</span> <span class="va">BayesRule</span><span class="op">)</span>,</span>
<span>  times <span class="op">=</span> <span class="fl">10</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Unit: milliseconds</span></span>
<span><span class="co">#&gt;       expr      min        lq     mean    median        uq       max neval</span></span>
<span><span class="co">#&gt;  hatvalues    1.134    1.2507    1.426    1.4331    1.5707    1.7101    10</span></span>
<span><span class="co">#&gt;   Woodbury   43.312   46.9261   49.311   49.4191   52.3461   55.2943    10</span></span>
<span><span class="co">#&gt;      exact 1775.987 1795.8243 1942.600 1873.8817 1948.4393 2455.5474    10</span></span>
<span><span class="co">#&gt;     cv.glm 2038.583 2152.0934 2251.000 2195.1743 2359.3482 2551.4744    10</span></span></code></pre></div>
<p>There is a substantial time penalty associated with exact
computations.</p>
</div>
<div class="section level2">
<h2 id="computation-of-the-bias-corrected-cv-criterion-and-confidence-intervals">Computation of the bias-corrected CV criterion and confidence
intervals<a class="anchor" aria-label="anchor" href="#computation-of-the-bias-corrected-cv-criterion-and-confidence-intervals"></a>
</h2>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{CV}(\mathbf{y}, \widehat{\mathbf{y}})</annotation></semantics></math>
represent a cross-validation cost criterion, such as mean-squared error,
computed for all of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
values of the response
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math>
based on fitted values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat{\mathbf{y}}</annotation></semantics></math>
from the model fit to all of the data. We require that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{CV}(\mathbf{y}, \widehat{\mathbf{y}})</annotation></semantics></math>
is the mean of casewise components, that is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{CV}(\mathbf{y}, \widehat{\mathbf{y}}) = \frac{1}{n}\sum_{i=1}^n\mathrm{cv}(y_i, \widehat{y}_i)</annotation></semantics></math>.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;&lt;span class="citation"&gt;Arlot &amp;amp; Celisse (2010)&lt;/span&gt;
term the casewise loss,
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi mathvariant="normal"&gt;c&lt;/mi&gt;&lt;mi mathvariant="normal"&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo stretchy="true" form="prefix"&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mover&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo accent="true"&gt;̂&lt;/mo&gt;&lt;/mover&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo stretchy="true" form="postfix"&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\mathrm{cv}(y_i, \widehat{y}_i)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;,
the “contrast function.”&lt;/p&gt;'><sup>3</sup></a> For
example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">E</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathrm{MSE}(\mathbf{y}, \widehat{\mathbf{y}}) = \frac{1}{n}\sum_{i=1}^n (y_i - \widehat{y}_i)^2</annotation></semantics></math>.</p>
<p>We divide the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
cases into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
folds of approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>≈</mo><mi>n</mi><mi>/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">n_j \approx n/k</annotation></semantics></math>
cases each, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo>∑</mo><msub><mi>n</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">n = \sum n_j</annotation></semantics></math>.
As above, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐣</mi><annotation encoding="application/x-tex">\mathbf{j}</annotation></semantics></math>
denote the indices of the cases in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>th
fold.</p>
<p>Now define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mi>j</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><msup><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{CV}_j = \mathrm{CV}(\mathbf{y}, \widehat{\mathbf{y}}^{(j)})</annotation></semantics></math>.
The superscript
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(j)</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\widehat{\mathbf{y}}^{(j)}</annotation></semantics></math>
represents fitted values computed for all of the cases from the model
with fold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
omitted. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\widehat{\mathbf{y}}^{(-i)}</annotation></semantics></math>
represent the vector of fitted values for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
cases where the fitted value for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
case is computed from the model fit with the fold including the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
case omitted (i.e., fold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
for which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>𝐣</mi></mrow><annotation encoding="application/x-tex">i \in \mathbf{j}</annotation></semantics></math>).</p>
<p>Then the cross-validation criterion is just
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo>=</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><msup><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{CV} = \mathrm{CV}(\mathbf{y}, \widehat{\mathbf{y}}^{(-i)})</annotation></semantics></math>.
Following <span class="citation">Davison &amp; Hinkley (1997, pp.
293–295)</span>, the bias-adjusted cross-validation criterion is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">j</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>n</mi><mi>j</mi></msub><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">
\mathrm{CV}_{\mathrm{adj}} = \mathrm{CV} + \mathrm{CV}(\mathbf{y}, \widehat{\mathbf{y}}) - \frac{1}{n} \sum_{j=1}^{k} n_j \mathrm{CV}_j
</annotation></semantics></math></p>
<p>We compute the standard error of CV as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">E</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>n</mi></msqrt></mfrac><msqrt><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msubsup><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac></msqrt></mrow><annotation encoding="application/x-tex">
\mathrm{SE}(\mathrm{CV}) = \frac{1}{\sqrt n} \sqrt{ \frac{\sum_{i=1}^n \left[ \mathrm{cv}(y_i, \widehat{y}_i^{(-i)} ) - \mathrm{CV} \right]^2 }{n - 1} }
</annotation></semantics></math> that is, as the standard deviation of
the casewise components of CV divided by the square-root of the number
of cases.</p>
<p>We then use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">E</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{SE}(\mathrm{CV})</annotation></semantics></math>
to construct a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">100 \times (1 - \alpha)</annotation></semantics></math>%
confidence interval around the <em>adjusted</em> CV estimate of error:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">j</mi></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mn>1</mn><mo>−</mo><mi>α</mi><mi>/</mi><mn>2</mn></mrow></msub><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">E</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">j</mi></mrow></msub><mo>+</mo><msub><mi>z</mi><mrow><mn>1</mn><mo>−</mo><mi>α</mi><mi>/</mi><mn>2</mn></mrow></msub><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">E</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">V</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">
\left[ \mathrm{CV}_{\mathrm{adj}} - z_{1 - \alpha/2}\mathrm{SE}(\mathrm{CV}), \mathrm{CV}_{\mathrm{adj}} + z_{1 - \alpha/2}\mathrm{SE}(\mathrm{CV})  \right]
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>z</mi><mrow><mn>1</mn><mo>−</mo><mi>α</mi><mi>/</mi><mn>2</mn></mrow></msub><annotation encoding="application/x-tex">z_{1 - \alpha/2}</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>α</mi><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1 - \alpha/2</annotation></semantics></math>
quantile of the standard-normal distribution (e.g,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>≈</mo><mn>1.96</mn></mrow><annotation encoding="application/x-tex">z \approx 1.96</annotation></semantics></math>
for a 95% confidence interval, for which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>α</mi><mi>/</mi><mn>2</mn><mo>=</mo><mn>.975</mn></mrow><annotation encoding="application/x-tex">1 - \alpha/2 = .975</annotation></semantics></math>).</p>
<p><span class="citation">Bates, Hastie, &amp; Tibshirani (2023)</span>
show that the coverage of this confidence interval is poor for small
samples, and they suggest a much more computationally intensive
procedure, called <em>nested cross-validation</em>, to compute better
estimates of error and confidence intervals with better coverage for
small samples. We may implement Bates et al.’s approach in a later
release of the <strong>cv</strong> package. At present we use the
confidence interval above for sufficiently large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
which, based on Bates et al.’s results, we take by default to be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>400</mn></mrow><annotation encoding="application/x-tex">n \ge 400</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="why-the-complement-of-auc-isnt-a-casewise-cv-criterion">Why the complement of AUC isn’t a casewise CV criterion<a class="anchor" aria-label="anchor" href="#why-the-complement-of-auc-isnt-a-casewise-cv-criterion"></a>
</h2>
<p>Consider calculating AUC for folds in which a validation set contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>v</mi></msub><annotation encoding="application/x-tex">n_v</annotation></semantics></math>
observations. To calculate AUC in the validation set, we need the vector
of prediction criteria,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><msub><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>v</mi></msub><mo>×</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msub></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><msub><mi>n</mi><mi>v</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\widehat{\mathbf{y}}_{v_{(n_v \times 1)}} = (\widehat{y}_1, ..., \widehat{y}_{n_v})^T</annotation></semantics></math>,
and the vector of observed responses in the validation set,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐲</mi><msub><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>v</mi></msub><mo>×</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msub></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><msub><mi>n</mi><mi>v</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{y}_{v_{(n_v \times 1)}} = (y_1, \ldots, y_{n_v})^T</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">y_i \in \{0,1\}, \; i = 1, \ldots, n_v</annotation></semantics></math>.</p>
<p>To construct the ROC curve, only the ordering of the values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{\widehat{y}}_v</annotation></semantics></math>
is relevant. Thus, assuming that there are no ties, and reordering
observations if necessary, we can set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mi>v</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{\widehat{y}}_v = (1, 2, \ldots, n_v)^T</annotation></semantics></math>.</p>
<p>If the AUC can be expressed as the casewise mean or sum of a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cv}(\widehat{y}_i,y_i)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="false" form="postfix">}</mo><mo>×</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo>→</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cv}: \{1,2,...,n_v\}\times\{0,1\} \rightarrow [0,1]</annotation></semantics></math>,
then
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>v</mi></msub></munderover><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">U</mi><mi mathvariant="normal">C</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mi>v</mi></msub><mo>,</mo><msub><mi>𝐲</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
\label{eq:cw}
\tag{1}
\sum_{i=1}^{n_v} \mathrm{cv}(\widehat{y}_i,y_i) = \mathrm{AUC}(\mathbf{\widehat{y}}_v,\mathbf{y}_v)
\end{equation}</annotation></semantics></math> must hold for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><annotation encoding="application/x-tex">2^{n_v}</annotation></semantics></math>
possible values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐲</mi><mi>v</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>y</mi><msub><mi>n</mi><mi>v</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{y}_v = (y_1,...,y_{n_v})^T</annotation></semantics></math>.
If all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">y\mathrm{s}</annotation></semantics></math>
have the same value, either 1 or 0, then the definition of AUC is
ambiguous. AUC could be considered undefined, or it could be set to 0 if
all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>s
are 0 and to 1 if all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>s
are 1. If AUC is considered to be undefined in these cases, we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{n_v} - 2</annotation></semantics></math>
admissible values for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>.</p>
<p>Thus, equation () produces either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><annotation encoding="application/x-tex">2^{n_v}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{n_v}-2</annotation></semantics></math>
constraints. Although there are only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">2n_v</annotation></semantics></math>
possible values for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi><mrow><mo stretchy="true" form="prefix" mathvariant="normal">(</mo><mo mathvariant="normal">⋅</mo><mo stretchy="true" form="postfix" mathvariant="normal">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cv(\cdot)}</annotation></semantics></math>
function, equation () could, nevertheless, have consistent solutions. We
therefore need to determine whether there is a value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>v</mi></msub><annotation encoding="application/x-tex">n_v</annotation></semantics></math>
for which () has no consistent solution for all admissible values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>.
In that eventuality, we will have shown that AUC cannot, in general, be
expressed through a casewise sum.</p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>v</mi></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n_v=3</annotation></semantics></math>,
we show below that () has no consistent solution if we include all
possibilities for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>,
but does if we exclude cases where all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>s
have the same value. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>v</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n_v=4</annotation></semantics></math>,
we show that there are no consistent solutions in either case.</p>
<p>The following R function computes AUC from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐲</mi><mo accent="true">̂</mo></mover><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{\widehat{y}}_v</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>,
accommodating the cases where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>
is all 0s or all 1s:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">AUC</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">y</span>, <span class="va">yhat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">s</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">s</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="fu">Metrics</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/Metrics/man/auc.html" class="external-link">auc</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">yhat</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We then define a function to generate all possible
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>s
of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>v</mi></msub><annotation encoding="application/x-tex">n_v</annotation></semantics></math>
as rows of the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐘</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>×</mo><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">\mathbf{Y}_{(2^{n_v} \times n_v)}</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Ymat</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n_v</span>, <span class="va">exclude_identical</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html" class="external-link">stopifnot</a></span><span class="op">(</span><span class="va">n_v</span> <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span></span>
<span>              <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">n_v</span><span class="op">)</span> <span class="op">==</span> <span class="va">n_v</span><span class="op">)</span>    <span class="co"># n_v must be a positive integer</span></span>
<span>  <span class="va">ret</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span> <span class="op">^</span> <span class="va">n_v</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>                <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>                  <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">as.integer</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html" class="external-link">intToBits</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">n_v</span>,<span class="op">]</span></span>
<span>  <span class="va">ret</span> <span class="op">&lt;-</span> <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">is.matrix</a></span><span class="op">(</span><span class="va">ret</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">ret</span><span class="op">)</span></span>
<span>  <span class="kw">else</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">ret</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">ret</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"y"</span>, <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">ret</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">exclude_identical</span><span class="op">)</span></span>
<span>    <span class="va">ret</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">ret</span><span class="op">)</span><span class="op">)</span>,<span class="op">]</span></span>
<span>  <span class="kw">else</span></span>
<span>    <span class="va">ret</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>v</mi></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n_v=3</annotation></semantics></math>,</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">Ymat</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;      y1 y2 y3</span></span>
<span><span class="co">#&gt; [1,]  0  0  0</span></span>
<span><span class="co">#&gt; [2,]  1  0  0</span></span>
<span><span class="co">#&gt; [3,]  0  1  0</span></span>
<span><span class="co">#&gt; [4,]  1  1  0</span></span>
<span><span class="co">#&gt; [5,]  0  0  1</span></span>
<span><span class="co">#&gt; [6,]  1  0  1</span></span>
<span><span class="co">#&gt; [7,]  0  1  1</span></span>
<span><span class="co">#&gt; [8,]  1  1  1</span></span></code></pre></div>
<p>If we exclude
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐲</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\mathbf{y}_v</annotation></semantics></math>s
with identical values, then</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">Ymat</span><span class="op">(</span><span class="fl">3</span>, exclude_identical <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;      y1 y2 y3</span></span>
<span><span class="co">#&gt; [1,]  1  0  0</span></span>
<span><span class="co">#&gt; [2,]  0  1  0</span></span>
<span><span class="co">#&gt; [3,]  1  1  0</span></span>
<span><span class="co">#&gt; [4,]  0  0  1</span></span>
<span><span class="co">#&gt; [5,]  1  0  1</span></span>
<span><span class="co">#&gt; [6,]  0  1  1</span></span></code></pre></div>
<p>Here is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐘</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>
with corresponding values of AUC:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu">Ymat</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>, AUC <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="fu">Ymat</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>, <span class="fl">1</span>, <span class="va">AUC</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;      y1 y2 y3 AUC</span></span>
<span><span class="co">#&gt; [1,]  0  0  0 0.0</span></span>
<span><span class="co">#&gt; [2,]  1  0  0 0.0</span></span>
<span><span class="co">#&gt; [3,]  0  1  0 0.5</span></span>
<span><span class="co">#&gt; [4,]  1  1  0 0.0</span></span>
<span><span class="co">#&gt; [5,]  0  0  1 1.0</span></span>
<span><span class="co">#&gt; [6,]  1  0  1 0.5</span></span>
<span><span class="co">#&gt; [7,]  0  1  1 1.0</span></span>
<span><span class="co">#&gt; [8,]  1  1  1 1.0</span></span></code></pre></div>
<p>The values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cv}(\widehat{y}_i, y_i)</annotation></semantics></math>
that express AUC as a sum of casewise values are solutions of equation
(), which can be written as solutions of the following system of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><annotation encoding="application/x-tex">2^{n_v}</annotation></semantics></math>
linear simultaneous equations in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">2n_v</annotation></semantics></math>
unknowns:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐔</mi><mo>−</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>𝐜</mi><mn>0</mn></msub><mo>+</mo><mi>𝐘</mi><msub><mi>𝐜</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝐔</mi><mo>−</mo><mi>𝐘</mi><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>𝐜</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>𝐜</mi><mn>1</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">U</mi><mi mathvariant="normal">C</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>𝐘</mi><mo accent="true">̂</mo></mover><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
\label{eq:lin}
\tag{2}
(\mathbf{U} -\mathbf{Y}) \mathbf{c}_0 + \mathbf{Y} \mathbf{c}_1
=
[\mathbf{U} -\mathbf{Y}, \mathbf{Y}]
\begin{bmatrix}
\mathbf{c}_0 \\ \mathbf{c}_1
\end{bmatrix}
= \mathrm{AUC}(\mathbf{\widehat{Y}},\mathbf{Y})
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐔</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>×</mo><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">\mathbf{U}_{(2^{n_v} \times n_v)}</annotation></semantics></math>
is a matrix of 1s conformable with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐘</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐜</mi><mn>0</mn></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>v</mi></msub><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{c}_0 = [\mathrm{cv}(1,0), c(2,0), ..., \mathrm{cv}(n_v,0)]^T</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐜</mi><mn>1</mn></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>v</mi></msub><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{c}_1 = [\mathrm{cv}(1,1), c(2,1), ..., \mathrm{cv}(n_v,1)]^T</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝐔</mi><mo>−</mo><mi>𝐘</mi><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>×</mo><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">[\mathbf{U} -\mathbf{Y}, \mathbf{Y}]_{(2^{n_v} \times 2n_v)}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐜</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐜</mi><mn>1</mn></msub></mtd></mtr></mtable></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub><mo>×</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">\begin{bmatrix}\begin{aligned}
\mathbf{c}_0 \\ \mathbf{c}_1
\end{aligned}
\end{bmatrix}_{(2n_v \times 1)}</annotation></semantics></math> are
partitioned matrices; and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐘</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>×</mo><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">\mathbf{\widehat{Y}}_{(2^{n_v} \times n_v)}</annotation></semantics></math>
is a matrix each of whose rows consists of the integers 1 to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>v</mi></msub><annotation encoding="application/x-tex">n_v</annotation></semantics></math>.</p>
<p>We can test whether equation () has a solution for any given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>v</mi></msub><annotation encoding="application/x-tex">n_v</annotation></semantics></math>
by trying to solve it as a least-squares problem, considering whether
the residuals of the associated linear model are all 0, using the
“design matrix”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝐔</mi><mo>−</mo><mi>𝐘</mi><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{U} -\mathbf{Y}, \mathbf{Y}]</annotation></semantics></math>
to predict the “outcome”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">U</mi><mi mathvariant="normal">C</mi></mrow><msub><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>𝐘</mi><mo accent="true">̂</mo></mover><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msup><mn>2</mn><msub><mi>n</mi><mi>v</mi></msub></msup><mo>×</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm{AUC}(\mathbf{\widehat{Y}},\mathbf{Y})_{(2^{n_v} \times 1)}</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">resids</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n_v</span>,</span>
<span>                   <span class="va">exclude_identical</span> <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>                   <span class="va">tol</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">.Machine</span><span class="op">$</span><span class="va">double.eps</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu">Ymat</span><span class="op">(</span><span class="va">n_v</span>, exclude_identical <span class="op">=</span> <span class="va">exclude_identical</span><span class="op">)</span></span>
<span>  <span class="va">AUC</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">Y</span>, <span class="fl">1</span>, <span class="va">AUC</span><span class="op">)</span></span>
<span>  <span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">Y</span>, <span class="va">Y</span><span class="op">)</span></span>
<span>  <span class="va">opts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>warn <span class="op">=</span> <span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/on.exit.html" class="external-link">on.exit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span><span class="va">opts</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lsfit.html" class="external-link">lsfit</a></span><span class="op">(</span><span class="va">X</span>, <span class="va">AUC</span>, intercept <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span>  <span class="va">ret</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/residuals.html" class="external-link">residuals</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">ret</span> <span class="op">&lt;</span> <span class="va">tol</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">ret</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>    <span class="va">solution</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">solution</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"c("</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">n_v</span>, <span class="fl">1</span><span class="op">:</span><span class="va">n_v</span><span class="op">)</span>, <span class="st">","</span>,</span>
<span>                              <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">1</span>, each <span class="op">=</span> <span class="va">n_v</span><span class="op">)</span>, <span class="st">")"</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">ret</span>, <span class="st">"solution"</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/zapsmall.html" class="external-link">zapsmall</a></span><span class="op">(</span><span class="va">solution</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">ret</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The case
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>v</mi></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n_v=3</annotation></semantics></math>,
excluding identical
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>s,
has a solution:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">resids</span><span class="op">(</span><span class="fl">3</span>, exclude_identical <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0</span></span>
<span><span class="co">#&gt; attr(,"solution")</span></span>
<span><span class="co">#&gt; c(1,0) c(2,0) c(3,0) c(1,1) c(2,1) c(3,1) </span></span>
<span><span class="co">#&gt;    1.0    0.0   -0.5    0.5    0.0    0.0</span></span></code></pre></div>
<p>But, if identical
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>s
are included, the equation is not consistent:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">resids</span><span class="op">(</span><span class="fl">3</span>, exclude_identical <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.125</span></span></code></pre></div>
<p>For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>v</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n_v=4</annotation></semantics></math>,
there are no solutions in either case:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">resids</span><span class="op">(</span><span class="fl">4</span>, exclude_identical <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.083333</span></span>
<span><span class="fu">resids</span><span class="op">(</span><span class="fl">4</span>, exclude_identical <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.25</span></span></code></pre></div>
<p>Consequently, the widely employed AUC measure of fit for binary
regression cannot in general be used for a casewise cross-validation
criterion.</p>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0" line-spacing="2">
<div id="ref-ArlotCelisse:2010" class="csl-entry">
Arlot, S., &amp; Celisse, A. (2010). <span class="nocase">A survey of
cross-validation procedures for model selection</span>. <em>Statistics
Surveys</em>, <em>4</em>, 40–79. Retrieved from <a href="https://doi.org/10.1214/09-SS054" class="external-link">https://doi.org/10.1214/09-SS054</a>
</div>
<div id="ref-BatesHastieTibshirani:2023" class="csl-entry">
Bates, S., Hastie, T., &amp; Tibshirani, R. (2023). Cross-validation:
What does it estimate and how well does it do it? <em>Journal of the
American Statistical Association</em>, <em>in press</em>. Retrieved from
<a href="https://doi.org/10.1080/01621459.2023.2197686" class="external-link">https://doi.org/10.1080/01621459.2023.2197686</a>
</div>
<div id="ref-CantyRipley2022" class="csl-entry">
Canty, A., &amp; Ripley, B. D. (2022). <em>Boot: Bootstrap
<span>R</span> (<span>S</span>-plus) functions</em>.
</div>
<div id="ref-DavisonHinkley:1997" class="csl-entry">
Davison, A. C., &amp; Hinkley, D. V. (1997). <em>Bootstrap methods and
their applications</em>. Cambridge: Cambridge University Press.
</div>
<div id="ref-Fox:2016" class="csl-entry">
Fox, J. (2016). <em>Applied regression analysis and generalized linear
models</em> (Second edition). Thousand Oaks <span>CA</span>: Sage.
</div>
<div id="ref-FoxWeisberg:2019" class="csl-entry">
Fox, J., &amp; Weisberg, S. (2019). <em>An <span>R</span> companion to
applied regression</em> (Third edition). Thousand Oaks <span>CA</span>:
Sage.
</div>
<div id="ref-Hager:1989" class="csl-entry">
Hager, W. W. (1989). Updating the inverse of a matrix.
<em><span>SIAM</span> Review</em>, <em>31</em>(2), 221–239.
</div>
<div id="ref-Mersmann:2023" class="csl-entry">
Mersmann, O. (2023). <em>Microbenchmark: Accurate timing functions</em>.
Retrieved from <a href="https://CRAN.R-project.org/package=microbenchmark" class="external-link">https://CRAN.R-project.org/package=microbenchmark</a>
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by John Fox, Georges Monette.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
